<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sieve of Eratosthenes</title>
    <url>/2025/04/03/AlgorithmForPrimeNums/</url>
    <content><![CDATA[<h1 id="一、质数定义"><a href="#一、质数定义" class="headerlink" title="一、质数定义"></a>一、质数定义</h1><p>质数（素数）是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
<p>我们在很小的时候就有理论基础了，也就是耳熟能详的二三五七九，一三一十七……</p>
<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h2><p>质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数，否则称为合数。</p>
<h2 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. <strong>性质</strong></h2><p>质数的个数是无穷的。欧几里得的《几何原本》中有一个经典的证明。它使用了证明常用的方法：反证法。具体证明如下：</p>
<ul>
<li>假设质数只有有限的n个，从小到大依次排列为p1，p2，……，pn，设N &#x3D; p1×p2×……×pn，那么，N是素数或者不是素数。如果为素数，则要大于p1，p2，……，pn，所以它不在那些假设的素数集合中；如果为合数，因为任何一个合数都可以分解为几个素数的积；而N和N + 1的最大公约数是1，所以不可能被p1，p2，……，pn整除，所以该合数分解得到的素因数肯定不在假设的素数集合中。因此无论该数是素数还是合数，都意味着在假设的有限个素数之外还存在着其他素数。所以原先的假设不成立。也就是说，素数有无穷多个。</li>
</ul>
<p>其他数学家给出了一些不同的证明。欧拉利用黎曼函数证明了全部素数的倒数之和是发散的，恩斯特·库默的证明更为简洁，哈里·弗斯滕伯格则用拓扑学加以证明。</p>
<h2 id="3-数目计算"><a href="#3-数目计算" class="headerlink" title="3. 数目计算"></a>3. 数目计算</h2><p>尽管整个素数系统是无穷的，仍然有人会问“100，000以下有多少个素数？”，“一个随机的100位数多大可能是素数？”。素数定理可以回答此问题。</p>
<p>1、在一个大于1的数a和它的2倍之间（即区间（a,2a]中）必存在至少一个素数。</p>
<p>2、存在任意长度的素数等差数列。</p>
<p>3、一个偶数可以写成两个合数之和，其中每一个合数都最多只有9个质因数。（挪威数学家布朗，1920年）</p>
<p>4、一个偶数必定可以写成一个质数加上一个合成数，其中合数的因子个数有上界。（瑞尼，1948年）</p>
<p>5、一个偶数必定可以写成一个质数加上一个最多由5个因子所组成的合成数。后来，有人简称这结果为（1 + 5）（中国潘承洞，1968年）</p>
<p>6、一个充分大偶数必定可以写成一个素数加上一个最多由2个质因子所组成的合成数。简称为（1 + 2）</p>
<h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h2><p>质数被广泛地应用在密码学上，所谓的公钥就是将想要传递的信息在编码时加入质数，编码之后传送给收信人，任何人收到此信息后，若没有此收信人所拥有的密钥，则解密的过程中（实为寻找素数的过程），将会因为找质数的过程（分解质因数）过久，使即使取得信息也会无意义。在汽车变速箱齿轮的设计上，相邻的两个大小齿轮齿数设计成质数，以增加两齿轮内两个相同的齿相遇啮合次数的最小公倍数，可增强耐用度减少故障。在害虫的生物生长周期与杀虫剂使用之间的关系上，杀虫剂的质数次数的使用也得到了证明。实验表明，质数次数地使用杀虫剂是最合理的：都是使用在害虫繁殖的高潮期，而且害虫很难产生抗药性。以质数形式无规律变化的导弹和鱼雷可以使敌人不易拦截。多数生物的生命周期也是质数（单位为年），这样可以最大程度地减少碰见天敌的机会。</p>
<h1 id="二、素数算法"><a href="#二、素数算法" class="headerlink" title="二、素数算法"></a>二、素数算法</h1><p>寻找素数最朴素的方法当然是一个一个遍历，我们依次遍历每一个数，然后分别判断是否是素数。所以问题的核心又回到了判断素数上，那么怎么判断一个数是不是素数呢？</p>
<p>素数的性质只有一个，就是只有1和它本身这两个因数，我们要判断素数也只能利用这个性质。所以可以想到，假如我们要判断n是否是素数，可以从2开始遍历到n-1，如果这n-1个数都不能整除n，那么说明n就是素数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>显然，这个算法是可以优化的，比如当n是偶数的时候，我们根本不需要循环，除了2意外的偶数一定是合数。再比如，我们循环的上界其实也没有必要到n-1，到根号n就可以了。因为因数如果存在一定是成对出现的，如果存在小于根号n的因数，那么n除以它一定大于根号n。</p>
<p>这个改进也很简单，稍作改动即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> n != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="built_in">int</span>(math.sqrt(n) + <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这样我们把O(n)的算法优化到了O(n*(1&#x2F;2))也算是有了很大的改进了，但是还没有结束，我们还可以继续优化。由数学定理，只有形如6n-1和6n+1的自然数可能是素数，这里的n是大于等于1的整数。</p>
<p>这个定理乍一看好像很高级，但其实很简单，因为所有自然数都可以写成6n,6n+1,6n+2,6n+3,6n+4,6n+5这6种，其中6n,6n+2,6n+4是偶数，一定不是素数。6n+3可以写成3(2n+1)，显然也不是素数，所以只有可能6n+1和6n+5可能是素数。6n+5等价于6n-1，所以我们一般写成6n-1和6n+1。</p>
<p>利用这个定理，我们的代码可以进一步优化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">6</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">5</span>) <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="built_in">int</span>(math.sqrt(n) + <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>虽然这样已经很快了，但仍然不是最优的，尤其是当我们需要寻找大量素数的时候，仍会消耗大量的时间。那么有没有什么办法可以批量查找素数呢？</p>
<p>有的，这个方法叫做埃拉托斯特尼算法。这个名字念起来非常拗口，这是一个古希腊的名字。此人是个古希腊的大牛，是大名鼎鼎的阿基米德的好友。他虽然没有阿基米德那么出名，但是也非常非常厉害，在数学、天文学、地理学、文学、历史学等多个领域都有建树。并且还自创方法测量了地球直径、地月距离、地日距离以及黄赤交角等诸多数值。要知道他生活的年代是两千五百多年前，那时候中国还是春秋战国时期，可以想见此人有多厉害。</p>
<h2 id="1-埃式筛法"><a href="#1-埃式筛法" class="headerlink" title="1. 埃式筛法"></a>1. 埃式筛法</h2><p>埃拉托斯特尼算法就是他发明的用来筛选素数的方法，为了方便我们一般简称为埃式筛法或者筛法。埃式筛法的思路非常简单，就是用已经筛选出来的素数去过滤所有能够被它整除的数。这些素数就像是筛子一样去过滤自然数，最后被筛剩下的数自然就是不能被前面素数整除的数，根据素数的定义，这些剩下的数也是素数。</p>
<p>举个例子，比如我们要筛选出100以内的所有素数，我们知道2是最小的素数，我们先用2可以筛掉所有的偶数。然后往后遍历到3，3是被2筛剩下的第一个数，也是素数，我们再用3去筛除所有能被3整除的数。筛完之后我们继续往后遍历，第一个遇到的数是7，所以7也是素数，我们再重复以上的过程，直到遍历结束为止。结束的时候，我们就获得了100以内的所有素数。</p>
<p>这个思想非常简单，理解了之后写出代码来真的很容易：</p>
<pre><code class="language-python">def eratosthenes(n):
    primes = []
    is_prime = [True] * (n + 1)
    for i in range(2, n+1):
        if is_prime[i]:
            primes.append(i)
            # 用当前素数i去筛掉所有能被它整除的数
            for j in range(i * 2, n+1, i):
                is_prime[j] = False
    return primes
</code></pre>
<p>我们来分析一下筛法的复杂度，从代码当中我们可以看到，我们一共有了两层循环，最外面一层循环固定是遍历n次。而里面的这一层循环遍历的次数一直在变化，并且它的运算次数和素数的大小相关，看起来似乎不太方便计算。实际上是可以的，根据素数分布定理以及一系列复杂的运算（相信我，你们不会感兴趣的），我们是可以得出筛法的复杂度是O(nlnlnn)<br>。</p>
<h2 id="2-极致优化"><a href="#2-极致优化" class="headerlink" title="2. 极致优化"></a>2. 极致优化</h2><p>筛法的复杂度已经非常近似<br>了，因为即使在n很大的时候，经过两次ln的计算，也非常近似常数了，实际上在绝大多数使用场景当中，上面的算法已经足够应用了。</p>
<p>但是仍然有大牛不知满足，继续对算法做出了优化，将其优化到了<br>的复杂度。虽然从效率上来看并没有数量级的提升，但是应用到的思想非常巧妙，值得我们学习。在我们理解这个优化之前，先来看看之前的筛法还有什么可以优化的地方。比较明显地可以看出来，对于一个合数而言，它可能会被多个素数筛去。比如38，它有2和19这两个素因数，那么它就会被置为两次False，这就带来了额外的开销，如果对于每一个合数我们只更新一次，那么是不是就能优化到O(n)线性复杂度了呢？</p>
<p>怎么样保证每个合数只被更新一次呢？这里要用到一个定理，就是每个合数分解质因数只有的结果是唯一的。既然是唯一的，那么一定可以找到最小的质因数，如果我们能够保证一个合数只会被它最小的质因数更新为False，那么整个优化就完成了。</p>
<p>那我们具体怎么做呢？其实也不难，我们假设整数n的最小质因数是m，那么我们用小于m的素数i乘上n可以得到一个合数。我们将这个合数消除，对于这个合数而言，i一定是它最小的质因数。因为它等于i * n，n最小的质因数是m，i 又小于m，所以i是它最小的质因数，我们用这样的方法来生成消除的合数，这样来保证每个合数只会被它最小的质因数消除。</p>
<p>根据这一点，我们可以写出新的代码：</p>
<pre><code class="language-python">def ertosthenes(n):
    primes = []
    is_prime = [True] * (n+1)
    for i in range(2, n+1):
        if is_prime[i]:
            primes.append(i)
        for j, p in enumerate(primes):
            # 防止越界
            if p &gt; n // i:
                break
            # 过滤
   is_prime[i * p] = False
            # 当i % p等于0的时候说明p就是i最小的质因数
            if i % p == 0:
                break
                
    return primes
</code></pre>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>到这里，我们关于埃式筛法的介绍就告一段落了。埃式筛法的优化版本相对来说要难以记忆一些，如果记不住的话，可以就只使用优化之前的版本，两者的效率相差并不大，完全在可以接受的范围之内。</p>
<p>筛法看着代码非常简单，但是非常重要，有了它，我们就可以在短时间内获得大量的素数，快速地获得一个素数表。有了素数表之后，很多问题就简单许多了，比如因数分解的问题，比如信息加密的问题等等。这份两千多年前的智慧，今天仍在发光。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DynamicProgramming</title>
    <url>/2025/04/03/DynamicProgramming/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划作为算法设计的核心思想之一，广泛用于求解最优化问题。本文结合经典例题与个人实践理解，总结动态规划的核心思想、解题步骤及常见问题类型，帮助读者系统掌握这一方法。我们看看wiki上更正式的定义：</p>
<ul>
<li>动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。</li>
</ul>
<p>★ dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.</p>
<h2 id="一、动态规划的核心思想"><a href="#一、动态规划的核心思想" class="headerlink" title="一、动态规划的核心思想"></a>一、动态规划的核心思想</h2><p>动规最核心的思想就是拆分子问题，保存好过往，减少冗余。</p>
<h3 id="1-分治与冗余消除"><a href="#1-分治与冗余消除" class="headerlink" title="1. 分治与冗余消除"></a>1. <strong>分治与冗余消除</strong></h3><p>动态规划通过将复杂问题分解为重叠的子问题，并记录子问题的解以避免重复计算，本质是“分治思想”与“空间换时间”的结合。例如，高中期间常见的斐波那契数列，它的递归解法时间复杂度为 (O(2^n))，而动态规划则优化至了 (O(n))。</p>
<h3 id="2-最优子结构与无后效性"><a href="#2-最优子结构与无后效性" class="headerlink" title="2. 最优子结构与无后效性"></a>2. <strong>最优子结构与无后效性</strong></h3><ul>
<li><strong>最优子结构</strong>：问题的最优解包含子问题的最优解。例如，最大子序和中，若以 <code>dp[i]</code> 表示以第 <code>i</code> 个元素结尾的最大子数组和，则 <code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code>:cite[1]:cite[3]。</li>
<li><strong>无后效性</strong>：当前状态仅由直接前驱状态决定，与更早的历史无关。例如背包问题中，当前物品的选择仅依赖于剩余容量和前一个物品的选择。</li>
</ul>
<hr>
<h2 id="二、动态规划的解题步骤"><a href="#二、动态规划的解题步骤" class="headerlink" title="二、动态规划的解题步骤"></a>二、动态规划的解题步骤</h2><h3 id="1-定义状态与边界条件"><a href="#1-定义状态与边界条件" class="headerlink" title="1. 定义状态与边界条件"></a>1. <strong>定义状态与边界条件</strong></h3><ul>
<li><strong>状态定义</strong>：明确 <code>dp</code> 数组的含义。例如，<code>dp[i][j]</code> 可能表示字符串 <code>s[0..i]</code> 和 <code>t[0..j]</code> 的最长公共子序列长度。</li>
<li><strong>边界条件</strong>：初始化最小子问题的解。如 <code>dp[0] = nums[0]</code>（最大子序和）或 <code>dp[0][j] = 0</code>（背包问题空容量）。</li>
</ul>
<h3 id="2-构建状态转移方程"><a href="#2-构建状态转移方程" class="headerlink" title="2. 构建状态转移方程"></a>2. <strong>构建状态转移方程</strong></h3><p>这是动态规划的核心，需分析当前状态如何由前驱状态推导。例如：</p>
<ul>
<li><strong>最长递增子序列</strong>：<code>dp[i] = max(dp[j] + 1)</code>，其中 <code>j &lt; i</code> 且 <code>nums[j] &lt; nums[i]</code></li>
<li><strong>0-1背包问题</strong>：<code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-w_i] + v_i)</code></li>
</ul>
<h3 id="3-选择自顶向下或自底向上"><a href="#3-选择自顶向下或自底向上" class="headerlink" title="3. 选择自顶向下或自底向上"></a>3. <strong>选择自顶向下或自底向上</strong></h3><ul>
<li><strong>自底向上</strong>：通过循环迭代填充 <code>dp</code> 表，如最大子序和的 <code>O(n)</code> 解法。</li>
<li><strong>自顶向下（记忆化搜索）</strong>：通俗的说就是带着备忘录去递归求解并缓存结果，适合状态转移复杂或空间受限的场景，而备忘录通常使用一个数组或者一个哈希map来充当。</li>
</ul>
<h3 id="4-回溯构造最优解"><a href="#4-回溯构造最优解" class="headerlink" title="4. 回溯构造最优解"></a>4. <strong>回溯构造最优解</strong></h3><p>通过记录路径或反向推导，还原具体解。例如，最长公共子序列可通过 <code>dp</code> 表反向追踪字符匹配情况。</p>
<hr>
<h2 id="三、经典问题与变式分析"><a href="#三、经典问题与变式分析" class="headerlink" title="三、经典问题与变式分析"></a>三、经典问题与变式分析</h2><h3 id="1-最大子段和（LeetCode-53）"><a href="#1-最大子段和（LeetCode-53）" class="headerlink" title="1. 最大子段和（LeetCode 53）"></a>1. <strong>最大子段和（LeetCode 53）</strong></h3><ul>
<li><strong>状态定义</strong>：<code>f[i]</code> 表示以 <code>nums[i]</code> 结尾的最大子数组和。</li>
<li><strong>状态转移</strong>：<code>f[i] = MAX(f[i - 1], dp[i-1] + nums[i])</code>。</li>
<li><strong>优化</strong>：空间压缩至 <code>O(1)</code>，只需维护当前和与最大值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((b) &gt; (a) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* f = <span class="built_in">malloc</span>(numsSize * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans = f[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        f[i] = MAX(f[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        ans = MAX(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(f);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. <strong>背包问题</strong></h3><p>0-1背包：每个物品选或不选，状态转移方程关注容量与价值的平衡810。</p>
<p>完全背包：物品可重复选，需调整遍历顺序（如正序循环容量）5。</p>
<p>当然还有多重背包，分组背包以及结合其他内容出的题目。</p>
<p>推荐训练<a href="https://www.acwing.com/problem/search/1/?search_content=%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2&show_algorithm_tags=0">ACwing背包9讲</a></p>
<ol start="3">
<li>最长回文子串（LeetCode 5）<br>状态定义：dp[i][j] 表示子串 s[i..j] 是否为回文。</li>
</ol>
<p>转移方程：dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; dp[i+1][j-1]4。</p>
<p>其他就比如状态机，划分，还有很多，都需要大量练习，</p>
<p>四、常见误区与优化技巧</p>
<ol>
<li>误区<br>错误的状态定义：如将非关键因素纳入状态维度，导致复杂度爆炸。</li>
</ol>
<p>忽略无后效性：状态设计需保证当前决策不影响后续状态独立性。</p>
<ol start="2">
<li>优化技巧<br>空间压缩：滚动数组或变量替换。例如背包问题中，二维数组可优化为一维。</li>
</ol>
<p>剪枝与贪心结合：某些问题（如跳跃游戏）中，贪心策略可提前终止计算。</p>
<p>五、总结与学习建议<br>动态规划的学习需从经典问题入手，逐步掌握状态设计与转移方程的构建逻辑。建议：</p>
<p>多练习模板题：如最大子序和、背包问题、编辑距离等。</p>
<p>画表分析：手动填充 dp 表以理解状态转移过程。</p>
<p>结合实际问题：如资源调度、路径规划等，深化对最优子结构的理解。</p>
<p>动态规划不仅是算法工具，更是一种思维方式。通过不断实践与反思，方能真正掌握其精髓。</p>
<hr>
<p><strong>参考与推荐资料</strong>  </p>
<ul>
<li><p><a href="https://oi-wiki.org/dp/basic/">动态规划基础 -OI Wiki</a></p>
</li>
<li><p><a href="http://jianshu.com/p/65f3077d8e50">动态规划问题总结 - 简书</a>:cite[1]</p>
</li>
<li><p><a href="https://www.cnblogs.com/Anker/archive/2013/03/15/2961725.html">《算法导论》动态规划总结 - 博客园</a>:cite[8]</p>
</li>
<li><p><a href="https://gitcode.com/Open-source-documentation-tutorial/bb769/?utm_source=document_gitcode&index=top&type=card&webUrl&isLogin=1">算法导论</a></p>
</li>
<li><p><a href="https://leetcode.cn/discuss/post/3581838/fen-xiang-gun-ti-dan-dong-tai-gui-hua-ru-007o/">灵茶山艾府leetcode题单</a><img src="https://files.mdnice.com/user/94063/e737f65d-431e-4eb2-8797-d7879cf1448d.png"></p>
</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>TheSkyline</title>
    <url>/2025/04/06/TheSkyline/</url>
    <content><![CDATA[<h1 id="leetcode-218-天际线问题"><a href="#leetcode-218-天际线问题" class="headerlink" title="leetcode 218. 天际线问题"></a>leetcode 218. 天际线问题</h1><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在给你所有建筑物的位置和高度（坐标形式），请返回由这些建筑物形成的天际线（点列） 。<br>每个建筑物的几何信息由数组 buildings 表示，其中三元组</p>
<ul>
<li>buildings[i] &#x3D; [lefti, righti, heighti]</li>
</ul>
<p>表示: lefti 是第 i 座建筑物左边缘的 x 坐标。<br>righti 是第 i 座建筑物右边缘的 x 坐标。<br>heighti 是第 i 座建筑物的高度。<br>你可以假设所有的建筑都是完美的长方形，在高度为 0 的绝对平坦的表面上。</p>
<p>天际线 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],…] ，并按x坐标进行排序。<br>关键点是水平线段的左端点。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>注意：输出天际线中不得有连续的相同高度的水平线。<br>例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p>
<p>示例 1：</p>
<p>输入：buildings &#x3D; [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</p>
<p>输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]</p>
<p>解释：<br>图 A 显示输入的所有建筑物的位置和高度，<br>图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。</p>
<p><img src="https://files.mdnice.com/user/94063/96be6c83-7d18-4b19-8a85-bf4e63c5b406.png"></p>
<p>提示：</p>
<p>1 &lt;&#x3D; buildings.length &lt;&#x3D; 104</p>
<p>0 &lt;&#x3D; lefti &lt; righti &lt;&#x3D; 231 - 1</p>
<p>1 &lt;&#x3D; heighti &lt;&#x3D; 231 - 1</p>
<p>buildings 按 lefti 非递减排序</p>
<h1 id="分析问题："><a href="#分析问题：" class="headerlink" title="分析问题："></a>分析问题：</h1><p>题目其实并不是很复杂，就是给出了图形坐标信息，要我们给出关键点序列来描述天际线，但是问题就出在，朴素的扫描题大多是求面积，轮廓周长或者什么的大方向角度，但是题目的恶心之处在于，要输出的是关键点序列，有点像线代里面的阶梯型矩阵的转折点，所以这并不是一道必须用线段树来解决的问题。<br>由于苯人python和c++水平很差，看大佬的简短题解都不是特别能理解，所以就只能学学C的解法，整体思路和代码都来自leetcode，感谢大佬。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>结果要求的关键点序列，关键点的位置无疑是在各座大楼的左右边缘的，那么，我们就从左到右遍历所有建筑的左边缘、右边缘的横坐标，查看每一处是否可能出现天际线关键点。</p>
<h3 id="1-先定义三个优先队列"><a href="#1-先定义三个优先队列" class="headerlink" title="1. 先定义三个优先队列"></a>1. 先定义三个优先队列</h3><p>leftHeap，这是一个最小堆，里面以每一栋建筑的左边缘横坐标为标记进行排列，成为最小堆。</p>
<p>rightHeap，这是一个最小堆，里面以每一栋建筑的右边缘横坐标为标记进行排列，成为最小堆。</p>
<p>heightHeap，这是一个最大堆，里面以每一栋建筑的高度值为标记进行排列，成为最大堆。</p>
<h3 id="2-处理队列、数组"><a href="#2-处理队列、数组" class="headerlink" title="2. 处理队列、数组"></a>2. 处理队列、数组</h3><p>按照横坐标从小到大的顺序，对leftHeap和rightHeap进行逐个pop操作，以确保结果数组中，横坐标是从小到大的顺序。</p>
<p>每遍历到一处横坐标时，分别要得到三个数值。</p>
<ul>
<li>leftMax，所有左边缘横坐标等于当前位置的建筑的高度最大值。如果没有任何建筑的左边缘横坐标在此处，该值为0。如下图（左）所示，x &#x3D; 2的位置处，有三栋建筑的左边缘在这，其中最高的高度为leftMax &#x3D; 9。</li>
<li>rightMax，所有右边缘横坐标等于当前位置的建筑的高度最大值。如果没有任何建筑的右边缘横坐标在此处，该值为0。如下图（中）所示，x &#x3D; 10的位置处，有三栋建筑的右边缘在这，其中最高的高度为rightMax &#x3D; 8。</li>
<li>remainMax，所有包含该横坐标，但左右边缘不等于该横坐标的建筑的高度最大值。如果没有满足条件的建筑，该值为0。如下图（右）所示，x &#x3D; 6的位置处，有两栋建筑包含了此处坐标，且它们的左右边缘不在这里，它们中最高的是remainMax &#x3D; 6，左右边缘在这里的建筑不算在内。</li>
</ul>
<p>那么，我们可以直观地看出：<br>如果leftMax &#x3D;&#x3D; rightMax，则此处不会产生天际线值，因为各栋建筑的左右边缘等高，抹平了天际线。<br>如果remainMax &gt;&#x3D; MAX_VALUE(leftMax, rightMax)，则此处不会产生天际线值，因为背后更高的建筑，淹没了此处的天际线值。<br>除了上面两种情况，此处会产生一个天际线值，其横坐标就等于当前位置横坐标，高度则等于MAX_VALUE(remainMax, leftMax)。</p>
<p><img src="https://files.mdnice.com/user/94063/5702163e-aa1f-4fa5-8a06-40a8ca44fc85.png"></p>
<h3 id="3-代码（纯C）"><a href="#3-代码（纯C）" class="headerlink" title="3. 代码（纯C）"></a>3. 代码（纯C）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_FATHER(x)          ((0 == (x)) ? -1 : ((x) - 1 &gt;&gt; 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_LEFT(x)            (((x) &lt;&lt; 1) + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_RIGHT(x)           (((x) &lt;&lt; 1) + 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE(x, y)         (((x) &gt; (y)) ? (x) : (y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_VALUE(x, y)         (((x) &lt; (y)) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> **<span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> arraySize;</span><br><span class="line">&#125;</span><br><span class="line">HeapStruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 几个优先队列的push和pop操作函数。</span></span><br><span class="line"><span class="comment">几个优先队列中，leftHeap和rightHeap是最小堆，heightHeap是最大堆。</span></span><br><span class="line"><span class="comment">注意，里面存储的都是buildings数组的每个元素地址。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leftHeapPush</span><span class="params">(HeapStruct *heap, <span class="type">int</span> *bld)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leftHeapPop</span><span class="params">(HeapStruct *heap)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rightHeapPush</span><span class="params">(HeapStruct *heap, <span class="type">int</span> *bld)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rightHeapPop</span><span class="params">(HeapStruct *heap)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">heightHeapPush</span><span class="params">(HeapStruct *heap, <span class="type">int</span> *bld)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">heightHeapPop</span><span class="params">(HeapStruct *heap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数中的几个局部变量说明。</span></span><br><span class="line"><span class="comment">  mostValue:    int类型的最大值。题目中，横坐标和高度值都可以取到最大值。</span></span><br><span class="line"><span class="comment">  totalSize:    等于buildingsSize的两倍，即最多情况下，每栋建筑的左、右边缘各形成一个天际线值。</span></span><br><span class="line"><span class="comment">  x:            前面作为循环变量，后面作为天际线中的横坐标使用。</span></span><br><span class="line"><span class="comment">  left:         建筑的左边缘的横坐标。</span></span><br><span class="line"><span class="comment">  right:        建筑的右边缘的横坐标。</span></span><br><span class="line"><span class="comment">  leftMax:      某一个横坐标处，所有左边缘建筑的最大高度。</span></span><br><span class="line"><span class="comment">  rightMax:     某一个横坐标处，所有右边缘建筑的最大高度。</span></span><br><span class="line"><span class="comment">  remainMax:    某一个横坐标处，所有包含该坐标，但左右边缘不在此处的建筑最大高度。</span></span><br><span class="line"><span class="comment">  t1, t2, t3:   几个优先队列中使用的堆数组空间，由于存储的是地址，所以它们都是指针数组。</span></span><br><span class="line"><span class="comment">  leftHeap:     以建筑的左边缘横坐标为标记的优先队列，里面存储输入数组的元素地址，不是坐标本身。</span></span><br><span class="line"><span class="comment">  rightHeap:    以建筑的右边缘横坐标为标记的优先队列，同上，存储的是元素地址。</span></span><br><span class="line"><span class="comment">  heightHeap:   以建筑的高度为标记的优先队列，同上，存储的是元素地址。 */</span></span><br><span class="line"><span class="type">int</span> **<span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span> **buildings, <span class="type">int</span> buildingsSize, <span class="type">int</span> *buildingsColSize, <span class="type">int</span> *returnSize, <span class="type">int</span> **returnColumnSizes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mostValue = <span class="number">0x7FFFFFFF</span>, totalSize = buildingsSize &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>, leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>, remainMax = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *t1[buildingsSize], *t2[buildingsSize], *t3[buildingsSize];</span><br><span class="line">    HeapStruct leftHeap, rightHeap, heightHeap;</span><br><span class="line">    <span class="type">int</span> **result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* 堆空间初始化。数组空间分别使用三个不同数组，arraySize为0表示一开始是空堆。</span></span><br><span class="line"><span class="comment">    由于建筑总数在输入时是已知的，所以t1, t2, t3只要也使用同样长度，下面堆操作时就不会溢出。 */</span></span><br><span class="line">    leftHeap.<span class="built_in">array</span> = t1;</span><br><span class="line">    leftHeap.arraySize = <span class="number">0</span>;</span><br><span class="line">    rightHeap.<span class="built_in">array</span> = t2;</span><br><span class="line">    rightHeap.arraySize = <span class="number">0</span>;</span><br><span class="line">    heightHeap.<span class="built_in">array</span> = t3;</span><br><span class="line">    heightHeap.arraySize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 返回的结果数组空间初始化。暂不考虑malloc失败的异常处理。 */</span></span><br><span class="line">    result = (<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * totalSize);</span><br><span class="line">    *returnColumnSizes = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * totalSize);</span><br><span class="line">    *returnSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 左右边缘依次入堆。</span></span><br><span class="line"><span class="comment">    题目给出输入的建筑数组是按照左边缘横坐标排序的，所以，其实这里的leftHeapPush可以写成如下：</span></span><br><span class="line"><span class="comment">    leftHeap[x] = buildings[x]; 不过为了看起来易懂，采用下面的操作，即便输入数组未排序也可使用。 */</span></span><br><span class="line">    <span class="keyword">while</span>(buildingsSize &gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        leftHeapPush(&amp;leftHeap, buildings[x]);</span><br><span class="line">        rightHeapPush(&amp;rightHeap, buildings[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 依次出堆。leftHeap和rightHeap，谁的堆顶横坐标值较小，就先用这个横坐标。</span></span><br><span class="line"><span class="comment">    以此确保结果数组中，横坐标是从小到大的顺序。 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span> &lt; leftHeap.arraySize || <span class="number">0</span> &lt; rightHeap.arraySize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 当前横坐标位置，记录到变量x中。 */</span></span><br><span class="line">        left = (<span class="number">0</span> &lt; leftHeap.arraySize) ? leftHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>] : mostValue;</span><br><span class="line">        right = (<span class="number">0</span> &lt; rightHeap.arraySize) ? rightHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">1</span>] : mostValue;</span><br><span class="line">        x = MIN_VALUE(left, right);</span><br><span class="line">        <span class="comment">/* 堆heightHeap中，采用延迟出堆的方式，即所有右边缘小于等于x的，都出堆。</span></span><br><span class="line"><span class="comment">        因为此时，所有右边缘小于等于x的建筑，俱往矣，不会再对后面的数值产生影响。</span></span><br><span class="line"><span class="comment">        然后，如果还有多余，则堆顶高度就是背景建筑。</span></span><br><span class="line"><span class="comment">        这里采用延迟出堆，是因为pop操作只能针对堆顶，其余建筑可能早就右边缘小于等于x，只是之前不在堆顶无法pop。 */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> &lt; heightHeap.arraySize &amp;&amp; x &gt;= heightHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            heightHeapPop(&amp;heightHeap);</span><br><span class="line">        &#125;</span><br><span class="line">        remainMax = (<span class="number">0</span> &lt; heightHeap.arraySize) ? heightHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">2</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 堆rightHeap中，等于x的右边缘一起出堆。 */</span></span><br><span class="line">        rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> &lt; rightHeap.arraySize &amp;&amp; x == rightHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            rightMax = MAX_VALUE(rightMax, rightHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            rightHeapPop(&amp;rightHeap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 堆leftHeap中，等于x的左边缘一起出堆。</span></span><br><span class="line"><span class="comment">        左边缘出现后，这栋建筑的高度值就开始生效了，同时把高度加入到高度堆中。 */</span></span><br><span class="line">        leftMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> &lt; leftHeap.arraySize &amp;&amp; x == leftHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            leftMax = MAX_VALUE(leftMax, leftHeap.<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            heightHeapPush(&amp;heightHeap, leftHeap.<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">            leftHeapPop(&amp;leftHeap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 检查是否可以出现新的天际线。remainMax此时是背景最大值。</span></span><br><span class="line"><span class="comment">        如果leftMax等于rightMax，表示此处的建筑，左边的最高值等于右边最高值，正好抹平。</span></span><br><span class="line"><span class="comment">        如果remainMax大于等于leftMax和rightMax，则背景建筑的高度，淹没了此处的天际线值。</span></span><br><span class="line"><span class="comment">        除上面两种情况以外，都会出现新的天际线值。 */</span></span><br><span class="line">        <span class="keyword">if</span>(leftMax != rightMax &amp;&amp; remainMax &lt; MAX_VALUE(leftMax, rightMax))</span><br><span class="line">        &#123;</span><br><span class="line">            result[*returnSize] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">            (*returnColumnSizes)[*returnSize] = <span class="number">2</span>;</span><br><span class="line">            result[*returnSize][<span class="number">0</span>] = x;</span><br><span class="line">            result[*returnSize][<span class="number">1</span>] = MAX_VALUE(remainMax, leftMax);</span><br><span class="line">            (*returnSize)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左边缘最小堆push。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leftHeapPush</span><span class="params">(HeapStruct *heap, <span class="type">int</span> *bld)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> son = heap-&gt;arraySize, father = HEAP_FATHER(son);</span><br><span class="line">    <span class="comment">/* 堆size加一。 */</span></span><br><span class="line">    heap-&gt;arraySize++;</span><br><span class="line">    <span class="comment">/* 新加入的元素，预设放置在堆尾处，然后根据它和父节点的左边缘横坐标的大小关系，进行位置调整。 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != father &amp;&amp; heap-&gt;<span class="built_in">array</span>[father][<span class="number">0</span>] &gt; bld[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[son] = heap-&gt;<span class="built_in">array</span>[father];</span><br><span class="line">        son = father;</span><br><span class="line">        father = HEAP_FATHER(son);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[son] = bld;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左边缘最小堆pop。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leftHeapPop</span><span class="params">(HeapStruct *heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> father = <span class="number">0</span>, left = HEAP_LEFT(father), right = HEAP_RIGHT(father), son = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *bld = heap-&gt;<span class="built_in">array</span>[heap-&gt;arraySize - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">/* 堆size减一。 */</span></span><br><span class="line">    heap-&gt;arraySize--;</span><br><span class="line">    <span class="comment">/* 堆顶pop之后，留下空缺，先预设将堆尾的元素填补上来，然后根据它和子节点的左边缘横坐标的大小关系，进行位置调整。 */</span></span><br><span class="line">    <span class="keyword">while</span>((heap-&gt;arraySize &gt; left &amp;&amp; heap-&gt;<span class="built_in">array</span>[left][<span class="number">0</span>] &lt; bld[<span class="number">0</span>])</span><br><span class="line">        || (heap-&gt;arraySize &gt; right &amp;&amp; heap-&gt;<span class="built_in">array</span>[right][<span class="number">0</span>] &lt; bld[<span class="number">0</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        son = (heap-&gt;arraySize &gt; right &amp;&amp; heap-&gt;<span class="built_in">array</span>[right][<span class="number">0</span>] &lt; heap-&gt;<span class="built_in">array</span>[left][<span class="number">0</span>]) ? right : left;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[father] = heap-&gt;<span class="built_in">array</span>[son];</span><br><span class="line">        father = son;</span><br><span class="line">        left = HEAP_LEFT(father);</span><br><span class="line">        right = HEAP_RIGHT(father);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[father] = bld;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右边缘最小堆push。</span></span><br><span class="line"><span class="comment">处理逻辑和上面左边缘最小堆的一样，只是上面的左边缘，改成这里的右边缘。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rightHeapPush</span><span class="params">(HeapStruct *heap, <span class="type">int</span> *bld)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> son = heap-&gt;arraySize, father = HEAP_FATHER(son);</span><br><span class="line">    heap-&gt;arraySize++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != father &amp;&amp; heap-&gt;<span class="built_in">array</span>[father][<span class="number">1</span>] &gt; bld[<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[son] = heap-&gt;<span class="built_in">array</span>[father];</span><br><span class="line">        son = father;</span><br><span class="line">        father = HEAP_FATHER(son);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[son] = bld;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右边缘最小堆pop。</span></span><br><span class="line"><span class="comment">处理逻辑和上面左边缘最小堆的一样，只是上面的左边缘，改成这里的右边缘。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rightHeapPop</span><span class="params">(HeapStruct *heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> father = <span class="number">0</span>, left = HEAP_LEFT(father), right = HEAP_RIGHT(father), son = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *bld = heap-&gt;<span class="built_in">array</span>[heap-&gt;arraySize - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;arraySize--;</span><br><span class="line">    <span class="keyword">while</span>((heap-&gt;arraySize &gt; left &amp;&amp; heap-&gt;<span class="built_in">array</span>[left][<span class="number">1</span>] &lt; bld[<span class="number">1</span>])</span><br><span class="line">        || (heap-&gt;arraySize &gt; right &amp;&amp; heap-&gt;<span class="built_in">array</span>[right][<span class="number">1</span>] &lt; bld[<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        son = (heap-&gt;arraySize &gt; right &amp;&amp; heap-&gt;<span class="built_in">array</span>[right][<span class="number">1</span>] &lt; heap-&gt;<span class="built_in">array</span>[left][<span class="number">1</span>]) ? right : left;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[father] = heap-&gt;<span class="built_in">array</span>[son];</span><br><span class="line">        father = son;</span><br><span class="line">        left = HEAP_LEFT(father);</span><br><span class="line">        right = HEAP_RIGHT(father);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[father] = bld;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高度最大堆push。</span></span><br><span class="line"><span class="comment">处理逻辑和上面左边缘最小堆的一样，只是上面的左边缘，改成这里的高度值，上面的最小堆，改成这里的最大堆。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">heightHeapPush</span><span class="params">(HeapStruct *heap, <span class="type">int</span> *bld)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> son = heap-&gt;arraySize, father = HEAP_FATHER(son);</span><br><span class="line">    heap-&gt;arraySize++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != father &amp;&amp; heap-&gt;<span class="built_in">array</span>[father][<span class="number">2</span>] &lt; bld[<span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[son] = heap-&gt;<span class="built_in">array</span>[father];</span><br><span class="line">        son = father;</span><br><span class="line">        father = HEAP_FATHER(son);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[son] = bld;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 高度最大堆pop。</span></span><br><span class="line"><span class="comment">处理逻辑和上面左边缘最小堆的一样，只是上面的左边缘，改成这里的高度值，上面的最小堆，改成这里的最大堆。 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">heightHeapPop</span><span class="params">(HeapStruct *heap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> father = <span class="number">0</span>, left = HEAP_LEFT(father), right = HEAP_RIGHT(father), son = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *bld = heap-&gt;<span class="built_in">array</span>[heap-&gt;arraySize - <span class="number">1</span>];</span><br><span class="line">    heap-&gt;arraySize--;</span><br><span class="line">    <span class="keyword">while</span>((heap-&gt;arraySize &gt; left &amp;&amp; heap-&gt;<span class="built_in">array</span>[left][<span class="number">2</span>] &gt; bld[<span class="number">2</span>])</span><br><span class="line">        || (heap-&gt;arraySize &gt; right &amp;&amp; heap-&gt;<span class="built_in">array</span>[right][<span class="number">2</span>] &gt; bld[<span class="number">2</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        son = (heap-&gt;arraySize &gt; right &amp;&amp; heap-&gt;<span class="built_in">array</span>[right][<span class="number">2</span>] &gt; heap-&gt;<span class="built_in">array</span>[left][<span class="number">2</span>]) ? right : left;</span><br><span class="line">        heap-&gt;<span class="built_in">array</span>[father] = heap-&gt;<span class="built_in">array</span>[son];</span><br><span class="line">        father = son;</span><br><span class="line">        left = HEAP_LEFT(father);</span><br><span class="line">        right = HEAP_RIGHT(father);</span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;<span class="built_in">array</span>[father] = bld;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：恒等式 <br>链接：<a href="https://leetcode.cn/problems/the-skyline-problem/solutions/2128263/tian-ji-xian-wen-ti-you-xian-dui-lie-by-qhcm1/">https://leetcode.cn/problems/the-skyline-problem/solutions/2128263/tian-ji-xian-wen-ti-you-xian-dui-lie-by-qhcm1/</a> <br>来源：LeetCode</p>
]]></content>
      <tags>
        <tag>-算法</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp</title>
    <url>/2025/03/16/csapp/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>从江西到川大网安</title>
    <url>/2025/03/15/fromJXtoSCUCSE/</url>
    <content><![CDATA[<h2 id="from-JX-to-SCUCSE"><a href="#from-JX-to-SCUCSE" class="headerlink" title="from JX to SCUCSE"></a>from JX to SCUCSE</h2><p>从江西到四川大学网络空间安全学院（cyberspacesecurityengineering）<br>engineering这个词很灵性，代表本专业的工学性，计算机科学工程属性，还有建设和研究之意。</p>
<h3 id="12-year-Odessey-of-Striving-and-Relishing"><a href="#12-year-Odessey-of-Striving-and-Relishing" class="headerlink" title="12-year Odessey of Striving and Relishing"></a>12-year Odessey of Striving and Relishing</h3><ul>
<li>泰和县第三实验小学</li>
<li>泰和县第四中学</li>
<li>吉安市白鹭洲中学</li>
<li>四川大学</li>
</ul>
<h3 id="过去的经历"><a href="#过去的经历" class="headerlink" title="过去的经历"></a>过去的经历</h3><p>我在中国南方江西省一个常见的县城长大，现代高速城市化的风气让小县城建设得也十分尽然有序，街道建设风格也逐渐和几年以后我上学的市区相差无几，我的少年时期在身边所有人的陪同下变得十分美好，即使是被Foreign educator认为有点不正常的中国孩子教育培养模式笼罩，我也一直乐观而勇敢，这种性格保持到了今天，当然现在的我不可能毫无烦恼，不断成长总会带来挥之不去的些许烦恼。<br>小学时期过的很慢，每天几乎都是同样的路线上下学，学习上的话，好像一年级会考不及格呢，到最后毕业了，无数有趣的经历变成了一本毕业证书，我也在那时和很多朋友完成了彼此的同学录，不过这是第一个也是最后一个，长大一点的我变得不是那么天真，甚至有点骄纵而不愿做这些。<br>初中我认识到了我的数学启蒙老师：黄老师，我清晰地记得初中开学考试考了年级15，他高兴地说我天赋很好，一定会考到市一中，未来去个好大学，浙大武大什么的。因为家里不方便写作业，初中三年我一直在他的家中被托管写作业，（小学的时候也有在一个托管机构吃中饭睡觉，高考完也去拜访了那对老师，还是和记忆里一样的模样，很美好啊）在他的影响下，我的数学思维和兴趣被发掘的很快，当时大片大片的几何难题，都是越做越顺畅呢。小初中的其他老师也都很好，他们是我人生中遇到的第一份宝藏，授予了我丰富的知识，更引导我成为一个全面向善，志向远大的青年。<br>中考也以不错的成绩收尾，如果不是体育的小插曲，应该如黄老师所言进入市一中宏志班了，但是缘分便是如此，来到白鹭中中学进修，何尝不是我人生的幸事呢？<br>高中三年的故事如灿星弥空，从高一上住宿生活到分班，不断进步，最后取得不错的结果，里面有太多有意思的故事了，上学期期末周复习思政的时候，我还在想要不要写一份文章，或者说一本自传，把我18年的故事写下，可以给未来我遇到的良知益友分享，当然还是没有行动，因为回忆实在太难写好了，此刻这篇博客也只是我的first essay，只是让阅读的您对我有初步了解。总之，我很高兴能来到白鹭中中学学习，这里聚集了很多优秀而多彩的同学，毕业之后，有很多都来到了国内一流985&#x2F;211大学，大家也在心中保留着这份美好的回忆。<br>初高中六年时光如梭，我在这六年时间学习了太多，打造了不错的数理基础，值得骄傲的是，从故事的开头到结尾，我很有幸一直是班级的领军人物，虽然高考语文比中考还低让我有点难以接受，但是数理英语还是不错的，总是让每一任老师都很放心，高考出分，最后被川大网安录取，让家族里面每个人都很高兴。彼时我已经在四川大学网络空间安全学院学习了一个学期，cs和cse无数丰富的知识都在探索中，希望您和我一同努力，成为自己心目中应该成为的模样。</p>
<h3 id="未来的期望"><a href="#未来的期望" class="headerlink" title="未来的期望"></a>未来的期望</h3><p>来到四川大学网络空间安全学院，我正努力学习着基础知识，并不断提高我的实践能力。生活上我乐观幽默，和所有人都能打成一片，游戏方面玩的很杂也不多，竞技类优秀和体育游戏最多，音乐艺术方面的细胞不多，但是有很好听的音乐也可以分享给我哦，运动的话会打打篮球，有点喜欢踢足球，看电影、享受美食、旅游探险这些都算是爱好吧。技术上的话，当然是希望变成一个大大大黑客，当然现在有很多不会的，安全工作需要的就是经验和不断得学习以汲取经验，所以努力学习吧！</p>
<h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><h2 id="感谢你的阅读！更感谢18年来所有支持我的人，尤其是我的家人，爱你们3000遍。"><a href="#感谢你的阅读！更感谢18年来所有支持我的人，尤其是我的家人，爱你们3000遍。" class="headerlink" title="感谢你的阅读！更感谢18年来所有支持我的人，尤其是我的家人，爱你们3000遍。"></a>感谢你的阅读！<br>更感谢18年来所有支持我的人，尤其是我的家人，爱你们3000遍。</h2>]]></content>
      <tags>
        <tag>About me</tag>
        <tag>过去或未来？</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn_1</title>
    <url>/2025/03/20/pwn/</url>
    <content><![CDATA[<p>##环境搭建</p>
<p>已经正式学习pwn有一会了，学会了基本操作流程，做一点点（真的是很有限的）简单题目，pwn的入门实在不能做无痛，向学长询问和看教程配置环境都用了蛮久，所以在此总结分享</p>
<p>###开始搭建环境</p>
<p>##虚拟机创建<br>从ubuntu官网找长期支持版本下载，在vm中新建虚拟机，打开新建虚拟机向导，选择自定义，硬件兼容性不用改-&gt;安装程序网盘映像文件，设置username和password，处理器和内核数量2 1就够，虚拟机内存的话一般4G就够-&gt;网络选择，对于学生党，学校的ip可能有接入限制，所以一般不选桥接网络访问外部以太网，选NAT（主机被抽象为网关，虚拟机则为其下的机器，保证开机后可以直接联网就行啦反正）-&gt;后面io控制器、磁盘类型都默认就行-&gt;然后是磁盘空间，建议大一些好（maybe60G?，后期做kernel pwn很占空间（苯人还不会），这样就创建好了虚拟机。</p>
<p>##基本配置<br>apt软件源更新，安装vim、pwntools、pwndbg、LibcSearcher、checksec、qemu等等，pwn的工具还是比较多的，python环境的话我选择vscode+fittencode，在主机也常用的python帮手。工具安装的话我参考的是这个：<a href="https://starrysky1004.github.io/2024/10/05/pwn-huan-jing-pei-zhi/">https://starrysky1004.github.io/2024/10/05/pwn-huan-jing-pei-zhi/</a> 这一步可以慢慢来，毕竟在使用的时候可能会发现自己忘了什么哈哈。然后是zsh+ohmyzsh来美化你的shell，毕竟好看的工具让人更有动力，参考的主要是这篇：<a href="https://blog.csdn.net/m0_72357534/article/details/135453423">https://blog.csdn.net/m0_72357534/article/details/135453423</a> 其中主题使用的是powerlevel10k，很推荐。</p>
<p>![可参考学习路线]{<a href="https://hornos3.github.io/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-1/pwn%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png=">https://hornos3.github.io/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-1/pwn%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF.png=</a> 150x150}</p>
<hr>
]]></content>
      <tags>
        <tag>-pwn -ubuntu</tag>
      </tags>
  </entry>
</search>
